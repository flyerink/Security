* 名称：`Command_Definition_Syntax`
* 日期：2021-09-20
* 拉取请求：[#24](https://github.com/opencomputeproject/Security/pull/24)

# 客观的

目前，Cerberus 协议命令（以下简称“协议结构”）的字节布局是通过包含偏移量的表来临时定义的。这些表存在许多问题：
- 它们很难编辑，因为它们是基于偏移的。
- 在某些情况下，它们不必要地冗长。
- 它们不是机器可读的。

此 RFC 为表提出了一种形式化的语法，该语法在常见情况下是机器可读且简洁的。

# 提议

每个表格在 Markdown 中看起来如下所示：
```
`消息 <名称>`
| 类型 | 名称 | 说明 |
| ---- | ---- | ---------- |
...
```
每个表都定义了一种消息类型。每个消息类型都包含一个名称和一些字段。每个字段都包含一个类型、一个名称和一个可选的描述。

消息名称必须采用 `CamelCase`，可选用句点分隔组件；字段名称必须在 `snake_case` 中。所有表格单元格，除了描述，都用反引号括起来。

特殊字段名称 _ 可用于保留/未使用的字段。

描述应该是完整的句子。虽然理想情况下描述应该放在一行中，但这并不总是可能的；如果描述超过 80 列的限制，它应该尽可能地继续，在最后一句话的句号之后以 `|` 结束。

编辑表格时，建议使用像 http://markdowntable.com/ 这样的格式化程序。

## 常见类型

绝大多数 Cerberus 消息的字段只是字节缓冲区，有时被解释为整数。有些缓冲区是可变长度的（带有长度前缀），有些缓冲区到消息末尾都是可变长度的。

以下类型旨在捕获这些用例：
- 固定宽度的位字符串，指定为“b”后跟一个文字整数。
  例如，“b1”是一位，“b32”是四个字节，“b256”是 32 个字节，足以用于 SHA2-256 摘要。`bN` 的长度是 `N` 位。
  `b0` 格式正确，并指定该字段根本未编码。
  主要值与下文讨论的“align”结合使用。

- 文字位串，指定为 C 风格的十六进制或二进制文字，例如“0xabcd”或“0b101010”。二进制文字的宽度是二进制数字的个数：
  ‘0b0001’是四位；前导零很重要。十六进制文字的宽度是十六进制数字的四倍：“0x0abcd”是 20 位。同样，前导零很重要。

- 其他消息类型，由该类型的名称指定。`MyMessage` 类型表示 `MyMessage` 内联的完整表示。当引用文档中的另一条消息时，如果该消息包含常用的点分隔前缀，则可以将其省略。例如，`Foo.Bar.Baz` 可以在 `Foo.Bar` 中称为 `Baz`，而 `Foo.Bar.Baz` 可以将 `Foo.Bar` 称为 `Bar`。

- 枚举类型映射，指定为“Map(field)”，其中“field”是枚举类型的前一个字段，“Map”是该字段的类型映射（见下文）。
  该字段被编码为映射指定的类型。

- 固定长度数组：任何其他类型后跟“[N]”，其中“N”是一个文字整数值，由连接的该类型的编码组成。例如，`b8[32]` 相当于`b256`，而`MyMessage[2]` 是两个背靠背的`MyMessages`，如果`MyMessage` 是可变长度的，则可能是可变长度的。

  如果类型是 `b8`，可以省略：`[32]` 是 32 字节。

- 可变长度数组：任何其他类型后跟“[field]”或“[Map(field)]”，其中“field”是前一个字段，“Map”是枚举值映射（见下文）。`field` 的内容（作为位）被解释为小端整数，它指定要遵循的类型的副本数。例如，如果 `foo` 是 `b16`，则 `MyMessage[foo]` 与 `foo` 指定的 `MyMessage` 一样多，当被视为无符号 16 位整数时。

  如果类型是 `b8`，可以省略：`[field]` is `b8[field]`

- 可变长度前缀数组：后跟“[bN]”的任何其他类型，其中“N”是文字整数值。`T[bN]` 相当于编码一个名为 `length` 的 `bN` 后跟一个 `T[length]`。例如，`b8[b16]` 是一个十六位前缀，后跟那么多字节。

  如果类型是 `b8`，可以省略：`[b16]` is `b8[b16]`

- 可变长度无前缀数组：任何其他类型后跟“...”。这被编码为该类型的多个副本，直到消息结束。
  例如，`b8...` 是到消息末尾的所有字节，`MyMessage...` 表示解析 `MyMessage` 直到字节用完。
  `...` 字段必须是消息中的最后一个字段，此类消息只能作为其他消息中的最后一个字段出现，不能用于构造数组类型。

  如果类型是 `b8`，它可能被省略：`...` is `b8...`

除非另有说明，否则字节以小端顺序形成整数，并且位根据底层传输在字节内排序；消息的大小四舍五入到一个字节。例如，包含两个“b1”字段的消息是一个字节长，这些字段代表该字节的最低和次低有效位。

以下是来自当前挑战协议规范的代表性示例：

`消息挑战.响应`
| 类型 | 名称 | 说明 |
|------------|----------------|--------------------------------------------------|
| `b8` | `插槽` | 证书链的槽号。|
| `b8` | `slot_mask` | 证书插槽掩码。|
| `b8` | `最小版本` | 设备支持的最低协议版本。|
| `b8` | `最大版本` | 设备支持的最大协议版本。|
| `0x0000` | `_` | 预订的。|
| `b256` | `nonce` | 随机 256 位随机数。|
| `[b8]` | `pmr0` | PMR0（聚合固件摘要）的内容。|
| `...` | `签名` | 在连接的请求和响应有效负载上签名。|

`消息KeyExchange.Request.PairedKeyHmac`
| 类型 | 名称 | 说明 |
|--------|--------------------|--------------------------------------------|
| `0x01` | `键类型` | 发送的密钥数据的类型。|
| `b16` | `pairing_key_len` | 配对密钥的长度，以字节为单位。|
| `...` | `pairing_key_hmac` | 配对密钥的 HMAC：`HMAC(K_M, K_P)`。|

`消息证明日志格式`
| 类型 | 名称 | 说明 |
|------------|--------------------|----------------------------------------------|
| `0x0b` | `header_format` | 标头格式版本。|
| `b16` | `条目长度` | 条目的总长度。|
| `b32` | `unique_id` | 条目的唯一标识符。|
| `b32` | `tcg_type` | 关联的 TCG 事件类型。|
| `b8` | `measurement_index` | PMR 内的测量指标。|
| `b8` | `pmr_index` | 正在扩展的 PMR 的索引。|
| `0x0000` | `_` | 预订的。|
| `b8` | `摘要计数` | 摘要数。|
| `0x0000` | `_` | 预订的。|
| `0x0b` | `digest_algo_id` | 摘要算法 ID，固定为 SHA-256。|
| `b256` | `摘要` | SHA-256 摘要用于扩展测量。|
| `[b32]` | `测量` | 测量值。|

### Alignment结盟

字段类型后面可能跟有 align(n) ，其中 n 是文字整数。这指定该字段必须对齐到相对于消息开头的“n”字节边界。填充必须全为零，并且可以是可变长度，具体取决于前面字段的长度。例如：

`消息AlignedBuf`
| 类型 | 名称 | 说明 |
|----------------|--------|----------------------------------|
| `b16` | `len` | 缓冲区长度。|
| `[len]` | `缓冲区` | 缓冲器。|
| `[len] 对齐（4）` | `buf2` | 另一个缓冲区，但 4 字节对齐。|

如果 len 为 3，则 buf 将占用字节 2 到 5。`4` 的下一个倍数是 `8`，所以在 `buf2` 的第一个字节之前会有三个字节的零填充。

`b0 align(n)` 可以用作最后一个字段以指示尾部填充。

对齐对于存储在内存中而不是从字节流反序列化的类型最有用。

## 枚举

一些字段具有固定大小并采用一小组值。就像 `message` 一样，`enum` 名称是带句点的 `CamelCase`，它们的值必须是 `snake_case`。值可以是十六进制或二进制，并且宽度必须相同。

`枚举 GetCertState.CertState`
| 价值 | 名称 | 说明 |
|--------|--------------------|----------------------------------------------|
| `0x00` | `chain_provisioned` | 已提供有效的链。|
| `0x01` | `chain_missing` | 尚未提供有效的链。|
| `0x02` | `验证` | 存储链当前正在验证中。|

然后可以直接在“类型”列中使用：

`消息GetCertState`
| 类型 | 名称 | 说明 |
|------------|----------------|----------------------------------------------|
| `CertState` | `cert_state` | 当前证书状态。|
| `b32` | `错误细节` | 证书验证错误的详细信息（如果已发生）。|

`enum` 可以*映射*以提供其值的替代编码。

如果我们有一个像 `enum HashType` 这样的枚举
| 价值 | 名称 | 说明 |
|--------|------------|------------|
| `0b00` | `sha2_256` | SHA2-256。|
| `0b01` | `sha2_324` | SHA2-384。|
| `0b10` | `sha2_512` | SHA2-512。|

我们可以像这样*映射*它：`enum HashLength(HashType)`
| 价值 | 名称 |
|--------|------------|
| `32` | `sha2_256` |
| `48` | `sha2_324` |
| `64` | `sha2_512` |

请注意括号中映射枚举的名称。它满足与消息字段相同的命名空间规则。

因为宽度并不重要，所以除了十六进制或二进制之外，还可以使用十进制整数。然后可以使用它来指定可变长度数组：`b8[HashLength(hash_type)]`。

地图也可能产生类型：

`枚举摘要（HashType）`
| 类型 | 名称 |
|--------|------------|
| `b256` | `sha2_256` |
| `b384` | `sha2_324` |
| `b512` | `sha2_512` |

这些可以直接用作字段：`Digest(hash_type)`。

# 规范变更列表

除了更新所有表以使用新语法外，还将添加一个新规范“Cerberus 模式表规范”，对上述形式语言进行描述。

# 未决问题

这个方案无法处理一些消息，我们需要决定是让这些消息符合它还是在方案中引入新的选项：
- “获取配置 ID”需要将两个长度前缀相加。
  我们可以通过使用两个背靠背的“T[field]”来解决这个问题，每个字段的值都有。长度前缀的乘法可以通过`T[field1][field2]`来实现。
- “Get $Manifest Id”消息有一个可选字段，“Get Recovery Image Id”也是如此。
  我们可以通过为它们使用 `T...` 来解决这个问题，并使用 prose 来指定默认值。我们还可以添加“直到最后但具有最大长度”的语法，例如`T[...n]`，但这对我来说似乎有点过分了。